/**
 * Generated by tinybird migrate.
 * Review endpoint output schemas and any defaults before production use.
 */

import { createKafkaConnection, defineDatasource, definePipe, defineMaterializedView, defineCopyPipe, node, t, engine, column, p } from "@tinybirdco/sdk";

// Connections

export const stream = createKafkaConnection("stream", {
  bootstrapServers: "localhost:9092",
  securityProtocol: "SASL_SSL",
  saslMechanism: "PLAIN",
  key: "api-key",
  secret: "api-secret",
  sslCaPem: "ca-pem-content",
});

// Datasources

/**
 * Events from Kafka stream
 */
export const events = defineDatasource("events", {
  description: "Events from Kafka stream",
  schema: {
    event_id: column(t.string(), { jsonPath: "$.event_id" }),
    user_id: column(t.uint64(), { jsonPath: "$.user.id" }),
    env: column(t.string().default("prod"), { jsonPath: "$.env" }),
    is_test: column(t.bool().default(false), { jsonPath: "$.meta.is_test" }),
    updated_at: column(t.dateTime(), { jsonPath: "$.updated_at" }),
    payload: column(t.string().default("{}").codec("ZSTD(1)"), { jsonPath: "$.payload" }),
  },
  engine: engine.replacingMergeTree({ sortingKey: ["event_id", "user_id"], partitionKey: "toYYYYMM(updated_at)", primaryKey: "event_id", ttl: "updated_at + toIntervalDay(30)", ver: "updated_at", settings: { "index_granularity": 8192, "enable_mixed_granularity_parts": true } }),
  kafka: {
    connection: stream,
    topic: "events_topic",
    groupId: "events-consumer",
    autoOffsetReset: "earliest",
  },
  forwardQuery: `
SELECT *
FROM events_mv
  `,
  tokens: [
    { name: "events_read", permissions: ["READ"] },
    { name: "events_append", permissions: ["APPEND"] },
  ],
  sharedWith: ["workspace_a", "workspace_b"],
});

export const eventsRollup = defineDatasource("events_rollup", {
  jsonPaths: false,
  schema: {
    user_id: t.uint64(),
    total: t.uint64(),
  },
  engine: engine.summingMergeTree({ sortingKey: "user_id", columns: ["total"] }),
});

// Pipes

export const copyEvents = defineCopyPipe("copy_events", {
  datasource: eventsRollup,
  copy_mode: "replace",
  copy_schedule: "@on-demand",
  nodes: [
    node({
      name: "copy_node",
      sql: `
SELECT event_id, user_id
FROM events
      `,
    }),
  ],
  tokens: [
    { name: "copy_token" },
  ],
});

/**
 * Endpoint for filtered events
 */
export const eventsEndpoint = definePipe("events_endpoint", {
  description: "Endpoint for filtered events",
  params: {
    env: p.string().optional("prod"),
    user_id: p.uint64(),
  },
  nodes: [
    node({
      name: "base",
      description: "Base filter",
      sql: `
SELECT event_id, user_id, payload
FROM events
WHERE user_id = {{UInt64(user_id)}}
  AND env = {{String(env, 'prod')}}
      `,
    }),
    node({
      name: "endpoint",
      sql: `
SELECT event_id AS event_id, user_id AS user_id
FROM base
      `,
    }),
  ],
  endpoint: { enabled: true, cache: { enabled: true, ttl: 120 } },
  output: {
    event_id: t.string(),
    user_id: t.string(),
  },
  tokens: [
    { name: "endpoint_token" },
  ],
});

/**
 * Materialized rollup
 */
export const eventsMv = defineMaterializedView("events_mv", {
  description: "Materialized rollup",
  datasource: eventsRollup,
  deploymentMethod: "alter",
  nodes: [
    node({
      name: "rollup",
      sql: `
SELECT user_id, count() AS total
FROM events
GROUP BY user_id
      `,
    }),
  ],
  tokens: [
    { name: "mv_token" },
  ],
});

export const statsPipe = definePipe("stats_pipe", {
  params: {
    min_total: p.uint32().optional(10),
  },
  nodes: [
    node({
      name: "agg",
      sql: `
SELECT user_id, count() AS total
FROM events
GROUP BY user_id
      `,
    }),
    node({
      name: "final",
      sql: `
SELECT user_id, total
FROM agg
WHERE total > {{UInt32(min_total, 10)}}
      `,
    }),
  ],
  tokens: [
    { name: "stats_token" },
  ],
});
